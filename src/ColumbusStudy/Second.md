## 1주차 완전탐색 / 재귀 함수

### 완전 탐색이란?

완전탐색은 모든 경우의 수를 시도하여 정답을 찾는 방법으로, 무식하게 푼다는 의미로 Brute Force라고도 합니다. 상대적으로 간단한 방법이지만 경우의 수가 많아지면 시간이 오래걸린다는 단점이 있습니다.

**예시**: 4자리 번호로 된 자물쇠를 풀기 위해서 각 자리에 0~9 번호를 넣어보는 것이다. 즉, 0000부터 9999까지 해보는 것이다. 이 때 경우의 수는 10^4 = 10,000이다.

### 완전탐색 기법 종류

1. Brute Force
2. 비트마스크
3. 재귀함수
4. 순열
5. BFS/DFS

#### 단순 Brute-Force

특별한 기법 없이 for문과 if문으로 모든 경우의 수를 체크하여 답을 구함. 이 방법으로 해결 할 수 있는 문제가 많지 않음. 문제 일부분 해결할 때 사용.

#### 비트마스크(Bitmask)

각 원소를 두 가지 상태로 분류할 수 있을 때 사용. ex) 모든 경우의 수에서 각각의 원소가 포함되거나 포함되지 않는 경우.

### 재귀함수

재귀함수는 자기 자신 함수를 호출하여 작업을 수행하는 방식입니다. 호출된 함수는 스택에 저장되었다가 호출이 완료되면  스택에서 삭제됩니다. 재귀함수는 반복 코드를 간결하게 표현할 수 있게 해주지만, 사이클이 발생하지 않도록 주의해야 합니다.
( 반복문의 형태라고 생각하면 됌, 스택프레임을 사용하기 때문에 호출 위치에따라서 값이 달라진다, 매개변수, 지역정보, 복귀주소 등등 
그래서 출력 -> 3 2 1 DFS(n-1) 1 2 3 위치에 따라서 출력되는 부분이 다름)
#### 특징

1. **자기 호출(Self-Invocation**: 재귀 함수는 기본적으로 자신을 다시 호출하는 특징을 가집니다. 함수가 자신의 복사본(새로운 컨텍스트)을 만들어서 작동합니다.
2. **기저 조건(Base Case)**: 재귀 함수에는 항상 종료 조건 또는 기저 사례가 있어야 합니다. 이 조건이 만족되면 함수는 자신을 더 이상 호출하지 않고 결과를 반환합니다. 기저 조건이 없는 재귀 함수는 무한히 계속 호출하게되어, 최종적으로는 스택 오버플로우 오류를 발생시킵니다.
3. **상태 유지(State Maintenance)**: 재귀 함수의 각 호출은 자신만의 변수 복사본을 가지게 되므로, 함수는 자신의 상태를 유지할 수 있습니다. 반복문을 사용하는 경우와는 다르게 함수의 각 상황에서 상태를 유지할 수 있게 됩니다.
4. **인자 변화(Parameter Changes)**: 재귀 호출에 사용되는 인자는 문제를 점점 간단하게 만들거나, 문제에 대한 접근을 변경하는 데 사용됩니다. 이는 반복문의 반복 변수와 유사한 역할을 합니다.
5. **간결함(Simplicity)**: 재귀는 복잡한 문제를 생각하기 쉬운 여러 하위 문제로 분해하는 것을 가능하게 합니다. 일부 문제는 재귀적 방식으로 생각하면 코드가 더 간결하고 이해하기 쉬울 수 있습니다.
6. **효율성**: 재귀는 특히 수학적이거나 계산 복잡한 문제에 유용하지만, 대량일 경우 스택 오버플로우의 위험이 있습니다. 따라서 효율성이 저하될 수 있으므로, 대량의 데이터를 다루는 경우 이터레이션을 이용하거나 다른 방법을 고려해야 할 때도 있습니다.

#### 순열

서로 다른 n개를 일렬로 나열하는 경우의 수(순서 o) => n!. 서로 다른 n개중 r개를 뽑아 일렬로 나열하는 경우의 수(순서 o) => n!/(r-1)! = nPr. 시간 복잡도: O(n!). 시간 복잡도가 높은 편이라 n이 한 자리 수 경우일 때 고려.

#### BFS / DFS

- 너비 우선 탐색(BFS, Breadth-First Search): 하나 노드 방문 후 인접한 모든 노드 우선 방문. 두 노드 사이 최단 경로 구할 시 자주 사용. 큐 사용하여 구현.

- 깊이 우선 탐색(DFS, Depth-Fist Search): 하나 노드 방문 후 그 노드의 모든 자식 노드 우선 방문. BFS보다 검색 속도 느림. 재귀함수 사용하여 구현.