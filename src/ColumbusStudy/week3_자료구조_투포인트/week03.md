오답 노트
Week3

Q1. 에라토스테네스의 체

문제에 있는데로 에라토스테네스의 체 방식으로 문제를 풀어야 하는 문제이다.\
다만 기존 문제 해결 방식은 미리 해당 배수의 값을 모두 체크해놓고
체크된 값을 풀지 않고 넘어가는 방식이다.
근데, 여기는 몇번째의 확인 하는 부분이고, 또한 모든 숫자를 다 체크해야 하는 방식이 가장 큰 차이다.

Q2. 수학 숙제
특정 문자 안에 들어있는 숫자 값들을 저장 해놓고 
해당 숫자 값을 모두 합쳐서 출력하는 문제이다.

Pattern pa = Pattern.compile("\\d+");
그래서 일단 패턴을 하나 작성 해두고,
Matcher ma = pa.matcher(arr[i]);
해당 패턴에 맞는 매칭 되는 것을 찾는 것이다.

그래서 ma.find() 라는 list.add(Integer.parseInt(ma.group()));
그룹화 하여 출력하는 것이다.

Q3. DeQue 문제
일단 덱큐 자체를 처음봤기 때문에 해당 문제를 어떻게 접근 해야하는지 벙쪘다.
문제를 읽어봤을때 왼쪽수부터 가까운지, 오른쪽 수부터 가까운지 체크하고나서 어떤 방향에서 poll을 할지
결정하면 되는 문제였다.

이해하고보면 단순했다.

아래의 코드를 보다 싶이 덱에 있는 뽑아서 다시 넣는 과정이다.
그냥 큐를 생각해보면 offer 는 삽입, poll은 넣는거다. 그래서 처음, 마지막 과정만 붙여서 아래와 같이 사용하면
해당 문제는 쉽게 해결된다.

dq.pollFirst() 메소드는 덱의 첫 번째 요소를 제거하고 그 값을 반환합니다. 덱이 비어있는 경우 null이 반환됩니다.
dq.offerLast(element) 메소드는 덱의 마지막에 주어진 element를 추가합니다. 공간이 부족하여 요소를 추가할 수 없는 경우 false를 반환하며, 요소가 성공적으로 추가된 경우 true를 반환합니다


Q5. 포켓몬
포켓몬들이 주어지고, 해당 포켓몬을 포켓몬 숫자, 또는 문자열로 찾는 방식이였다.
하나의 해쉬맵으로 작성하려고 보니 벨류값으로 해당 키값을 찾는 로직 자체가 생각보다 문제가 많았다(시간복잡도)

하여 해당 문제를 빠르게 풀기 위해 차라리 어차피 숫자 순서대로 저장되는것이니까 해쉬맵을 2개를 생성하고,
해당 입력문자가 숫자일경우는 숫자로 키값을, 문자일경우 해당 문자로 포켓몬을 찾는방식으로 변경하였다.

Q6. 나무 셋팅해서 비율 구하기
몇개의 문자가 입력 될지 모르기때문에 해당은 while 문으로 무제한으로 돌려야 한다.
다만 해당 문제에서 무제한으로 돌릴경우 BufferedReader 를 사용할경우

String input;
while ((input = br.readLine()) != null && !input.equals("")) {
}

해당 코드처럼 작성해주는게 훨씬 효과 적이다.

그래서 나무를 무제한으로 입력 받고, 그리고 같은 나무가 있었을때 체크를 해야 하기때문에

HashMap<String, Integer> hm = new HashMap<>();
hm.put(String, hm.getOrDefault(String, 0) +1 ); 

방식으로 값이 없을경우 숫자값을 입력받을 수 잇도록 작성하였다.

그이후 한가지 더 중요한건 소수잡 4번째 자리숫까지 구해야 하기때문에
선언은 Double 로 작성 하였다.

double percent = (value / total) * 100;

Q7. 카드 게임2
숫자를 입력받으면 해당 숫자만큼 데이터를 쌓어서 앞의 숫자를 빼고 뒤에서 넣는 방식이였다
그래서 데큐문제로 접근하여 문제를 접근했다.

틀린 이유 해당 카드가 두장남았을때 맨 위의 카드를 옮기는 동작을 수행하지 말아야 하는데 해당 동작을 수행함
    dq.offerLast(dq.pollFirst());
    if (dq.size() == 1) {
        break;
    }
위와 같이 작성했을시 뽑고나서 무조건 데이터를 넣게되는데 (마지막 값이 바뀔수 있음);

    if (dq.size() > 1) {
        dq.offerLast(dq.pollFirst());
    }

데이터를 뽑고나서 그다음에 사이즈가 1보다 컷을경우만 해당 작업을 진행 했어야만 했다.

Q8. 패션왕 신해빈
해당 문제를 이해하는데 한참걸린거같다.

일단 문제가 해당 문제는 이해기 어려웠떤 부분이 입력 예제 부분이 잘못됐다고 생각했다.
하나의 케이스가 두개의 케이스로 나뉘어져서 노출된것으로 나온것으로 생각됐다 그래서 예제처럼
2를 입력 받구  ( 종류, 타입 ) 이라고생각했는데 완전 틀렸었다.

2를 입력받으면 케이스를 총 2번 돌린다는 식의 접근이 필요했다.

그래서 종류별로 케이스를 체크하고나서 같은 타입기준으로 여러개를 체크하구나서 그걸 숫자 카운트를 작성했다
n*m 개 -1(완전 알몸)

Q1. 주몽( 값옷만들기 )
처음 접근방식은 투포엔트 알고리즘 + 슬라이딩 윈도우라고 생각하여 접근을 했다
그래서 주어진 방식에서 lt , rt 를 하나씩 정하고 rt (lt+1) 씩 옮기면서 값을 더하면서
위치값을 찾아서 결과를 냈는데 아니였다.

그래서 다른 접근방식으로는 어차피 모든 가지수가 다 돌아야하면 2중 포문 돌리면 되지.. 하고 돌렸는데
계속 시간 초과가 나서, 투포인트 알고리즘을 다시 확인 했다.

일반적으로 투포인트 알고리즘은 정렬을 기본으로해서 왼쪽끝과 오른쪽끝부터 그 값을 찾아 나가는 알고리즘이라고 한다.

그래서 해당 방식으로 전체 코드를 변경하여 다시 작업을 진행 했다.

Q10. 싸이버개강총회 ( Cyber 개강총회 )
해당 알고리즘 접근을 일단 처음 시간이 주어지고 사이시간 그리고 모두 말하는 시간등이 주어졌다.
그래서 접근방식으로 이전에 했던 와일문을 무제한으로 데이터를 받아야하는 방식대로 생각하고 접근을 했다.

어차피 처음 시간 3개가 라인에서 주어질거라서 해당 부분을 배열로 잡고
비교하기 편하게 LocalTime에다가 넣어서 비교하려고 구분 지어봤다.

그리고나서 수업 시작전, 1번 수업 종료부터 총회 종료시간 사이 시간으로 +1 씩 값을 올려서 체크를 했지만
일단 문제가 내가 아는 비교 방법은 localTime.isBefore , isAfter 였다. 해당시간으로 최초 작성시 해당 시간에는
포함이 되지 않아 오류가 나서, !isAfter 가 아니면서 종강시간도 아닐때로 하니까 
수업시간까지 포함되서 체크되는것을 늦게 발견하게 됐다.

그래서 더 찾아보니 localTime 에도 compareTo 라는 메소드가 존재 했고, 
전 시간일경우 음수
같은시간이면 0
이후 시간이면 양수  값을 리턴 하는것이였다.

그래서 해당 부분으로 전체를 변경하고,

해쉬맵 대신 해쉬 셋으로 이전시간에 왔던 학생들을 중복없이 카운트 쳐버리고, 그리고 그 사이시간에 온사람들을
둘다 있을경우 해당 학생이 로그인 했다라고 작성 하였다.

long a = attendance.stream()
    .filter(validChat::contains)
    .count();