
Week1
Day01
Q1. https://www.acmicpc.net/submit/11720/75182713
문제의 경우는 어려운 부분은 없이 해결 가능했다.
다만 생각하지 못한 부분이 char - 값을 sum 을 해주기 위해서
value.charAt(i)-'0'; -> '0' 부분을 추가적으로 붙였다는 것이다.
> 또한 백준 문제를 풀면서 프로그래머스는 시작을 배열에 담아서 시작을 하는데, 백준의 경우는 공백으로 띄는 경우가 많았는데
> String[] arr = kb.next().trim().split("\\s"); 이렇게 작업을 시작하면 해당 문자열이 배열에 담겨서 작업하기 쉽다!
> arr.toCharArray();

Q2. https://www.acmicpc.net/problem/9046
해당 문제는 일단 문제를 이해하는데 엄청난 시간이 걸렸다.
사실 이해를 했다기 보다는, 기존 문제의 경우 내가 생각하기엔
영어에서 가장 많이 나오는 문자열은 'e' 라고 주어져 있는 상태에서 시작을 했다고 볼 수 있는거 같다.

결국엔 어떤 문장을 입력을 받더라도 문장에서 가장 많이 노출되는것은 e 일 것이고, 그리고 문장에서 중복된 알파벳은 무조건
나올것이다. 그래서 거의 대부분의 케이스가 '?'가 찍히게 되지 않을까 싶다.

for (char c : str.toCharArray()) {
    counts[c - 'a']++;
}

해당 코드 부분의 처음에 의아했던것은 왜 이렇게 담지 였고, 일단 알파벳 소문자가 97 - 122 라고 보여져 해당 캐릭터 값에
-97을 함으로서 카운트 0 부터 시작하도록 만든것이다.
반대로 생각해보면

(char) ('a' + maxIndex)

이렇게 작성시 아스시코드값에 만약 maxIndex가 5라면 +97을 더해 102 -> e값이 나올것이다.

Q3. https://www.acmicpc.net/problem/1157
해당 문제에서도 가장 간과 했던 부분이
cnt[x-'A']++; 여기 였던것으로 생각됩니다. cnt 값의 기준 자체가 일단현재 들어온 문자 - 'A' 값을 함으로
해당 문자열의 카운트값을 구하는 방식으로 갔습니다. 위와 동일한 케이스라고 보이고, 또한 문자 자체가
대소문자를 가리지 않는다고 들어왔기때문에 str.toUpperCase() 를 사용하여 전체 대문자로 변경하여 해당 부분을 작업함.

Q4. https://www.acmicpc.net/problem/9996
이 문제는 생각보다 쉽지만 어려웠다고 느낀게 문제에서 입력 받는 값은 들어올 데이터를 입력 받는다
라고 명시되어있어서 아래 입력값을 확인했을때 입력값 +1 이 되어있었다.
그래서 보니까 패턴도 추가적으로 입력을 받았어야 하는 부분이 보여서 해당 부분을 다시 입력을 받고 고민 하였다.
근데 입력을 받고 보니, 비교를 할때 해당 패턴과 매치가 되는지 안되는지를 파악하려고 했는데 그렇게 하는것보다는
일단 a*b ( a&b ) 등으로 매칭이 이뤄지니까 해당 문자열 패턴을 미리 만들고
String pa = kb.next().replace("*" , ".*");
Pattern.matches(pa, 비교할대상) 등올 작성하여 문제를 해결하였다.

. : 임의의 한 문자를 의미
* : 직전의 문자가 0번 이상 반복되는 것을 의미
+ : 직전의 문자가 1번 이상 반복되는 것을 의미
? : 직전의 문자가 없거나 한 번 나타나는 것을 의미

정규식도 파악해두어야 일반적으로 문제 해결이 가능할 것으로 보인다.
