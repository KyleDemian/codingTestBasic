
Week1
Day01
Q1. https://www.acmicpc.net/submit/11720/75182713
1. 문제 설명
> N개의 숫자가 공백 없이 쓰여있다. 이 숫자를 모두 합해서 출력하는 프로그램을 작성하시오.

2. 접근 방식
해당 코드는 일단 문제 자체가 간단하고, 특정 문자의 개수를 입력 받고, 그 입력받은 문자를 모두 합해서 출력하는 프로그램이다.
그렇기 때문에 가장 간단하게 생각해서 특정 문자를 1개씩 나눠서 받음 다음, 해당 값을 char의 값으로 가지고 나서
문자 값을 숫자값으로 변환하면 되겠다 생각이 들었다.

문제의 경우는 어려운 부분은 없이 해결 가능했다.
다만 생각하지 못한 부분이 char - 값을 sum 을 해주기 위해서
value.charAt(i)-'0'; -> '0' 부분을 추가적으로 붙였다는 것이다.
> 또한 백준 문제를 풀면서 프로그래머스는 시작을 배열에 담아서 시작을 하는데, 백준의 경우는 공백으로 띄는 경우가 많았는데
> String[] arr = kb.nextLine().trim().split("\\s"); 이렇게 작업을 시작하면 해당 문자열이 배열에 담겨서 작업하기 쉽다!
> arr.toCharArray();

Q2. https://www.acmicpc.net/problem/9046
해당 문제는 일단 문제를 이해하는데 엄청난 시간이 걸렸다.
사실 이해를 했다기 보다는, 기존 문제의 경우 내가 생각하기엔
영어에서 가장 많이 나오는 문자열은 'e' 라고 주어져 있는 상태에서 시작을 했다고 볼 수 있는거 같다.

결국엔 어떤 문장을 입력을 받더라도 문장에서 가장 많이 노출되는것은 e 일 것이고, 그리고 문장에서 중복된 알파벳은 무조건
나올것이다. 그래서 거의 대부분의 케이스가 '?'가 찍히게 되지 않을까 싶다.

for (char c : str.toCharArray()) {
    counts[c - 'a']++;
}

해당 코드 부분의 처음에 의아했던것은 왜 이렇게 담지 였고, 일단 알파벳 소문자가 97 - 122 라고 보여져 해당 캐릭터 값에
-97을 함으로서 카운트 0 부터 시작하도록 만든것이다.
반대로 생각해보면

(char) ('a' + maxIndex)

이렇게 작성시 아스시코드값에 만약 maxIndex가 5라면 +97을 더해 102 -> e값이 나올것이다.

Q3. https://www.acmicpc.net/problem/1157
해당 문제에서도 가장 간과 했던 부분이
cnt[x-'A']++; 여기 였던것으로 생각됩니다. cnt 값의 기준 자체가 일단현재 들어온 문자 - 'A' 값을 함으로
해당 문자열의 카운트값을 구하는 방식으로 갔습니다. 위와 동일한 케이스라고 보이고, 또한 문자 자체가
대소문자를 가리지 않는다고 들어왔기때문에 str.toUpperCase() 를 사용하여 전체 대문자로 변경하여 해당 부분을 작업함.

Q4. https://www.acmicpc.net/problem/9996
이 문제는 생각보다 쉽지만 어려웠다고 느낀게 문제에서 입력 받는 값은 들어올 데이터를 입력 받는다
라고 명시되어있어서 아래 입력값을 확인했을때 입력값 +1 이 되어있었다.
그래서 보니까 패턴도 추가적으로 입력을 받았어야 하는 부분이 보여서 해당 부분을 다시 입력을 받고 고민 하였다.
근데 입력을 받고 보니, 비교를 할때 해당 패턴과 매치가 되는지 안되는지를 파악하려고 했는데 그렇게 하는것보다는
일단 a*b ( a&b ) 등으로 매칭이 이뤄지니까 해당 문자열 패턴을 미리 만들고
String pa = kb.next().replace("*" , ".*");
Pattern.matches(pa, 비교할대상) 등올 작성하여 문제를 해결하였다.

. : 임의의 한 문자를 의미
* : 직전의 문자가 0번 이상 반복되는 것을 의미
+ : 직전의 문자가 1번 이상 반복되는 것을 의미
? : 직전의 문자가 없거나 한 번 나타나는 것을 의미

정규식도 파악해두어야 일반적으로 문제 해결이 가능할 것으로 보인다.

// JAVA 에서 문자를 숫자 그대로 가져오는 방법
// Character.getNumericValue(str.charAt(i));

// if(Character.isLowerCase(my_string.charAt(i))){
answer += Character.toUpperCase(my_string.charAt(i));

Q5.
1. 문제 설명
    Java 형태의 문자열 과 C++ 형태의 문자값을 받아서, 해당 문자값이 들어오면
    Java 형태의 파일 명을 C++ 형태의 파일명으로 , 반대로 C++ 형태의 문자를 JAVA 형태로 변경 할것

2. 접근 방식
    시간 접근 방법은 잘 모르겠고, 해당 문제에서 일단 C++ to Java의 경우는 무조건 "_" 가 표현되어 있다고 하여, 해당 문자가 포함되어있다면,
    그 문자를 기준으로 배열에 담고자 하였습니다. 그리고 담은 문자의 언더바는 삭제하고 첫글자를 대문자, 다른글자들을 소문자로 변경 하는 방식을 고려하여
    for 와 if를 열심히 사용하여 만듦
    그리고 JAVA to c++ 의 경우는 Character.isUppercase()가 있다는 기준으로 하여, 그 대문자 앞에다가 "_"를 붙이고, 그 대문자를 소문자로 변경하는 방식으로 작업 하였음.

3. 틀린 이유 설명
    해당 문제는 오류케이스들이 다양하게 있을거라고 생각하지 못했음. 그래서 해당 문제들이 어떻게 들어올지, 대소문자및 특수문자 포함
    그리고 다양한 문자열 언더바 연속으로 두개 등등 그런케이스들을 아예 생각하지 않고 작성 하였음

4. 올바른 접근 방식 및 해결 방식
    인터넷 검색 해보니 예제에 들어가있는 오류 케이스 뿐만이 아니라 다른 케이스들도 오류케이스인것들을 확인하여, 해당 하는 부분들을 전체 오류로 잡고 작업을 진행함.

Q6.
1. 문제 설명
    최대 공약수/ 최소 공배수
2. 접근 방식
    암기
3. 틀린 이유 설명

4. 올바른 접근 방식 및 해결 방식
    그냥 외움 int a , int b -> gcd -> (b==0) return a, return gcm(b, a%b);
                               lcm -> return (a*b)/gcm(a,b);

Q7.
1. 문제 설명
    n to m 까지의 소수를 출력 하시오, 0과 1을 제외

2. 접근 방식
    일단 배열을 만들고 배열에 특정 값 0 또는 Boolean 값을 받아 해당 값을 초기화 한상태에서 2중포문으로 해당 값의 배수를 전부 체크하도록 작업

3. 틀린 이유 설명
    출력시 일단 범위에 상관 없이 전체 소수를 출력을 진행 하였음
    배열에 담아서 해당 배열값을 기준으로 값을 가져오니까 배열의 값과 숫자의 값이 일치 하지 않는 문제가 발생 하였음.

4. 올바른 접근 방식 및 해결 방식
    최대값 기준으로 전체 배열을 만들고, 해당 배열에서 소수값을 가져오는 것으로 변경 하였음 n 부터 m 까지의 소수를 체크


Q8.
1. 문제 설명
    2진수의 숫자를 8진수로 변경하세요

2. 접근 방식
    2진수를 변경 하는 방법은 자바에서 Integer.toOctalString(num) 형태로 숫자를 넣어주면 변경 됩니다.
    하여 2진수의 숫자를 Integer.parseInt(num, 2); 를 입력을 받고 위의 방식으로 사용했습니다.

3. 틀린 이유 설명
    위의 방식처럼 사용했지만 계속 오류가 났습니다. 그래서 이거 범위때문이가 라는 생각이 들어서 Long도 동일하게 지원하여
    해당 방식으로 동일하게 사용했지만 오류가 났습니다.

4. 올바른 접근 방식 및 해결 방식
    다른 더 큰 숫자로 변경을 해야 한다고 하여 BigInteger를 사용하면 된다고 하여 그 방식을 사용 하였습니다.
    BigInteger num = new BigInteger(n.trim(), 2);
    num.toString(8);
    현재 2진수값을 그대로 빅인티저의 값에 담고, toString(8)을 사용하면 자동으로 진법변환이 됩니다.